<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
pre {font-family: "Consolas", "Lucida Console", monospace; margin-left:20pt; }
code {font-family: "Consolas", "Lucida Console", monospace; }
pre > i   { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > i  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
pre > em  { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
code > em { font-family: "Consolas", "Lucida Console", monospace;  font-style:italic; }
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example   { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract  { margin-left: 2em; background-color: #F5F6A2;  border: 1px solid #E1E28E; }

p.function    { }
.attribute    { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

.editor { color: #4444BB; font-style: normal; background-color: #DDDDDD; }

tab { padding-left: 4em; }
tab3 { padding-left: 3em; }

.link { float: right }

blockquote.std    { color: #000000; background-color: #F1F1F1;  border: 1px solid #D1D1D1;  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;  color: #000000; background-color: #FFEBFF;  border: 1px solid #ECD7EC;  padding-left: 0.5em; padding-right: 0.5em; ; }
blockquote.stdins { text-decoration: underline;  color: #000000; background-color: #C8FFC8;  border: 1px solid #B3EBB3; padding: 0.5em; }
table.header { border: 0px; border-spacing: 0;  margin-left: 0px; font-style: normal; }
table.poll { border: 1px solid black; border-spacing: 0px;  margin-left: 0px; font-style: normal; }
table { border: 1px solid black; border-spacing: 0px;  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;  padding-left: 0.4em; border: none;  padding-right: 0.4em; border: none; }
td { text-align: left;  padding-left: 0.4em; border: none;  padding-right: 0.4em; border: none; }

.revision   { /*color: #005599;*/ }
.grammar { list-style-type:none }

</style>

<title>Contract support &mdash; Working Paper</title>

</head>
<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;</th><th> </th><td>D2521R2</td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td>2022-03-15</td>
  </tr>
  <tr>
    <th>Audience:&nbsp;&nbsp;</th><th> </th><td>SG21</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td>
		<address>Gašper Ažman &lt;gasper dot azman at gmail dot com&gt;</address>
		<address>Joshua Berne &lt;jberne4 at bloomberg dot net&gt;</address>
		<address>Bronek Kozicki &lt;brok at spamcop dot net&gt;</address>
		<address>Andrzej Krzemieński &lt;akrzemi1 at gmail dot com&gt;</address>
		<address>Ryan McDougall &lt;mcdougall dot ryan at gmail dot com&gt;</address>
		<address>Caleb Sunstrum &lt;caleb dot sunstrum at gmail dot com&gt;</address>			
      </td>
  </tr>
</tbody></table>


<h1>Contract support &mdash; Working Paper</h1>

<p> This paper is a yet another proposal to add a minimum contract support framework to C++. It proposes nothing that hasn't
    already been described in either 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a> or
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">[P2461R1]</a>.
    </p>

<p> The goal in this paper is to structure the proposal in a different way, in order 
    to reflect what SG21 has consensus on and what remains a controversy. We treat the following as open issues:</p>
    
<ol>
<li>The choice of syntax.</li>
<li>Side effect elision and duplication.</li>
<li>The treatment of non-reference function parameters referenced in postconditions.</li>
</ol>

<p> We assume that the reader is already familiar with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a>.</p>


<h2><a name="rev">0. Revision history <span class="link">{rev}</span></a></h2>



<h3><a name="rev.r01">0.1. R0 → R1<span class="link">{rev.r01}</span></a></h3>

<ol>
  <li>We now disallow contract annotations on function re-declarations and overriding function declarations.</li>
	<li>Clarified what happens when a contract predicate contains a call to a virtual function.</li>
	<li>Included poll results on including postconditions in the MVP.</li>
	<li>Explained why we need mixed translation modes to be implementation-defined.</li>
	<li>Removed the text which suggested that implementing runtime precondition checks inside function bodies is a necessity.</li>
	<li>Described more special cases related to virtual functions: when a base class is a template parameter, and when 
	    a function overrides more than one virtual function.</li>
	<li>Clarified that we are aiming at freestanding implementations.</li>
	<li>No longer defining look-up in contract annotations by analogy with <code>noexcept</code>.</li>
	<li>Mixing translation modes is IFNDR.</li>
</ol>


<h3><a name="rev.r02">0.2. R1 → R2<span class="link">{rev.r02}</span></a></h3>

<ol>
  <li>Described the proposed evaluation order of preconditions and postconditions. See section <a href="#pro.ord">{pro.ord}</a>.</li>
	<li>Non-reference function parameters named in the postcondition must be declared <code>const</code>. See section <a href="#pro.arg">{pro.arg}</a>.</li>
	<li>Explained why reading the value of function arguments instead of function parameters cannot solve the problem of non-reference function parameters 
      referenced in postconditions. See section <a href="#pro.arg.out">{pro.arg.out}</a>.</li>
	<li>Changed the motivation for adding side effect removal: it is not efficiency, it is the intention to discourage programmers
	    from deliberately putting side effects in contract annotations.</li>
</ol>


<h2><a id="mot">1. Motivation <span class="link">{mot}</span></a></h2>

<p> The motivation for adding contract support framework to C++ is to enable the programmers to define in a formal way what constitutes
    a contact violation (and therefore a bug) in their programs. This information can be later used by different tools to perform
    static or dynamic analysis of the program, add instrumentation code, or generate documentation or programmer hints in the IDE.
		It has been described in more detail in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a>.
		We want contracts to be available in freestanding implementations.</p>

<p> The motivation for producing this paper is to focus on documenting the consensus of SG21.<p>



<h2><a id="not">2. Notation <span class="link">{not}</span></a></h2>

<p>Because the choice of syntax for contract annotations has no consensus yet, in this paper we use placeholder notation:</p>

<pre>
int select(int i, int j)
  PRE(i &gt;= 0)               <em>// precondition</em>
  PRE(j &gt;= 0)
  POST(r: r &gt;= 0)           <em>// postcondition; r names the return value</em>
{
  ASSERT(_state &gt;= 0);      <em>// assertion; not necessarily an expression</em>

  if (_state == 0) return i;
  else             return j;
}
</pre> 


<h2><a id="pro">3. Proposed characteristics <span class="link">{pro}</span></a></h2>


<h3><a id="pro.tri">3.1. Three declarations: preconditions, postconditions and assertions<span class="link">{pro.tri}</span></a></h3>

<p>We propose that all three types of declarations are included in the minimum contract support:</p>

<ol>
<li>Preconditions.</li>
<li>Postconditions.</li>
<li>Assertions.</li>
</ol>

<p>Although it is possible to add only preconditions to the language and gain some benefit, we believe that only the three components
   added together bring sufficient value to warrant the modification of the language. We also believe that the syntax and semantics of preconditions
   must be compatible with these of the postconditions. So even if the preconditions were to be added in isolation, we would have to
   have a polished design for postconditions. This means that preconditions are blocked on the postcondition design even for the "only preconditions" variant.
   </p>
	 
<p> The corresponding SG21 poll on 2021-12-14:</p>

<p>Poll: Postconditions should be in the MVP at this time.</p>

<table class="poll">
<tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
<tr><td>1</td><td>7</td><td>3</td><td>4</td><td>1</td></tr>
</table>
 



<h3><a id="pro.mod">3.2. Two translation modes<span class="link">{pro.mod}</span></a></h3>

<p> We propose that there are two modes that a translation unit can be translated in:</p>

<ol>
  <li><strong><em>No_eval</em></strong>: compiler checks the validity of expressions in contract annotations,
      but the annotations have no effect on the generated binary. Functions appearing in the predicate are odr-used.
      </li>
  <li><strong><em>Eval_and_abort</em></strong>: each contract annotation is checked at runtime.
      The check evaluates the corresponding predicate; if the result equals <code>false</code>,
      the program is stopped an error return value.
      </li>
</ol>

<p> Too many modes are not 
    necessary for the minimum contract implementation. The <em>No_eval</em> is required to provide no-overhead guarantee. The 
    <em>Eval_and_abort</em> is required, because if we only had <em>No_eval</em> mode, 
		users could start using contract annotations as (syntax-checked) comments, and might forget that these should always evaluate to <code>true</code>
		in the correct programs.
    </p>
    
<p> Can different translation units be translated in different modes? If we allowed it, 
    we would have to answer questions like, what happens when the
    header file with the following contents is <code>#include</code>d in two translation units:</p>
		
<pre>
inline void f(int i)
{
  ASSERT(i != 0); <em>// which translation mode?</em>
}
</pre>

<p> We do not want to prevent the implementations from enabling the "mixed mode" if they know how to answer the questions like the one above.
    At the same time, we do not want to force the implementaitons to offer the mixed mode. We also do not want to force them to diagnose
		the "mixed mode" situations, as this may not be easy or practical. Therefore, we propose for the MVP that the translation of different translation units in different modes in one program is ill-formed, no diagnostic required. This guarantees that the MVP is reasonably small an implementable, and leaves maximum freedom for the future additions. Ideally, we would also like to encourage the implementaitons to inform the programmers whether they support
		the mixed mode or not.</p> 


<h3><a id="pro.ord">3.3. Evaluation order<span class="link">{pro.ord}</span></a></h3>

<p> We propose the following evaluation order for preconditions and postconditions when a function is invoked. </p>

<ol>
<li>Function parameters are initialized.</li>
<li>Preconditions are evaluated.</li>
<li>Evaluation of the function body begins. (This includes constructor initialization list, function-try-block.)</li>
<li>The return value, if any, is produced, creating an object in the caller or through the temporary materialization. </li>
<li>The destructors of automatic objects are called.</li>
<li>The postconditions are evaluated. (The postcondition can already see the returned object, and still see the function parameters.)</li>
<li>The destructors of function parameters are called.</li>
</ol> 

<p> In this proposal throwing from the contract predicate triggers a call to <code>std::terminate()</code>, 
    therefore there is no way to observe whether preconditions and postconditions are called inside or outside the function.
    </p>		


<h3><a id="pro.lok">3.4. Name look-up<span class="link">{pro.lok}</span></a></h3>

<p> We propose that names referred in preconditions and postconditions are looked up as if they appeared 
    in a <code>decltype</code> in a <em>trailing-return-type</em>,
    if the function had one. In particular, this means that private members can appear in pre/post-conditions.</p>
		
<p> Programming guidelines often recommend that in contract predicates of public member
    functions one should only use the public interface of the class. This is to enable the user of the class 
		to check the precondition in case the object state is not known. However, this is only a guideline, and enforcing it in the language
    would break other use cases that do not subscribe to the above advice. Also,
		precondition checks on member functions may be impossible to write using the public interface of the class
		because the contracts of the accessors might lead to recursive contract checks even when accessors themselves are not recursive.
    </p>

<p> In general, the users must <em>ensure</em> that the precondition of the called function is satisfied.
    If they do that, they do not have to check the precondition.
    </p>

<p> Allowing the access to protected and private members enables a practical usage scheme.
    In general, function precondition is something that cannot be fully expressed as C++ expression.
    The implementers choose how much of the function precondition they want to check. They may choose
    to check some parts of the precondition by accessing private members that they do not want
    to expose to the users, for instance, because the private implementation may change over time
    or under configuration:
    </p>

<pre>class callback
{
#if !defined NDEBUG
  mutable int _call_count = 0;
#endif

  <em>// ...</em>

public:
  void operator() const
    <em>// real contract: this function can be called no more than 8 times,</em>
    <em>// so the precondition is that the function has been called 7 or less times</em>

#if !defined NDEBUG
    <em>// attempt to check the precondition</em>
    PRE(_call_count &lt;= 7);
#endif
};</pre>

<p> In the above example, the precondition can only be checked in debugging mode.
    Once <code>NDEBUG</code> is defined, member <code>_call_count</code> is removed
    and there is no way to test the precondition.
    </p>

<p> Also, a hypothetical constraint to use only public members in contract predicates
    could result in programmers turning their private and protected members into public
    members only to be able to express the pre- and postconditions, which does not
    sound like a good class design.

</p><p> This has been described in detail in
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1289r1.pdf">[P1289R1]</a>,
    and in fact adopted by EWG. </p>
		


<h3><a id="pro.ret">3.5. Naming the return value <span class="link">{pro.ret}</span></a></h3>

<p> It is possible to name the return value (or reference) in the postcondition, except for one situation: 
    when we use a return placeholder type and do not provide the definition from which the type could be deduced:</p>
		
<pre>auto get_digit()
  POST(c: is_digit(c)); <em>// error: decltype(c) unknown</em>
</pre>	

<p> This has been discussed in detail in
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1323r2.html">[P1323R2]</a>.
    </p>	
		

<h3><a name="pro.ptr">3.6. Indirect function calls
        <span class="link">{pro.ptr}</span></a></h3>


<p> Function pointers and references cannot have contract annotations,
    but functions with contract annotations can be assigned to them:</p>

<pre>using fpa = int(*)(int) PRE(true); <em>// error</em>

using fptr = int(*)(int);
int f(int i) PRE(i &gt;= 0);

fptr fp = f;  <em>// OK</em>
fp(1);        <em>// precondition is checked in Eval_and_abort mode</em>
</pre>

<p> In other words, contract annotations are not part of function type.
    This allows dynamically selecting behavior at runtime based on inputs.
    </p>

<pre>int fast(int i) PRE(i &gt; 0);  <em>// fast, but has a narrow contract</em>
int slow(int i) PRE(true);   <em>// wide contract, but slow</em>

int f(int i)
{
  int (*fp) (int) = i &gt; 0 ? fast : slow;
  return fp(i);   <em>// if fast() is called, its precondition is checked</em>
}
</pre>

<p> The consequence of allowing this behavior is that an implementation
    cannot check the precondition at the call site for indirect calls. 
		The check has to be performed either inside the function or in a thunk.</p>

<p> We propose the same behavior, for the same reasons, for function wrappers:</p>

<pre>
using fp = int(*)(int);
int f(int i) PRE(i &gt;= 0);

function&lt;int(int)&gt; fp = f;  <em>// OK</em>
fp(1);   <em>// precondition is checked in Eval_and_abort mode</em>
</pre>
	
	
<h3><a name="pro.vir">3.7. Virtual functions
        <span class="link">{pro.vir}</span></a></h3>

<p> Contract annotations may appear in virtual member function declarations,
    but only in non-overriding functions. 
    When a virtual function is overridden, the overriding function has implicitly the
    same set of preconditions and postconditions as the overridden function,
    the program is ill-formed if you try to declare contract annotations in the 
		overriding function explicitly, even if they look identical to the ones in the overridden function.
		</p>

<pre>
struct Base {
  virtual void f() PRE(p1());   <em>// ok: introducing the precondition</em>
};

struct Deriv1 : Base {
  void f() override;            <em>// ok: Deriv1::f has precondition p1()</em>
};

struct Deriv2 : Base {
  void f() override PRE(p1());  <em>// error: Deriv2::f has the precondition redeclared</em>
};

struct Deriv3 : Base {
  void f() override PRE(p2());  <em>// error: Deriv3::f has different precondition than Base</em>
};
</pre>
		
<p> The overriding function has the same contract annotations as the virtual function in the base
    class, and the names in the predicates are looked up in the context of the
    base class.</p>

<pre>
static const int N = 1; <em>// #1</em>

struct Base
{
  virtual void f() PRE(N == 1);
};

template &lt;int N&gt;       <em>// N is shadowed</em>
struct Deriv : Base
{
  void f() override;
};

int main()
{
  Deriv&lt;2&gt;{}.f(); <em>// precondition test passes</em>
}
</pre>

<p> The precondition in the overriding function is <code>N == 1</code>,
    but the name lookup is performed in the context of class <code>Base</code>,
    so it sees the global variable <code>N</code> declared in line #1.</p>
		
<p> If a predicate in the contract annotation of function <code>f</code> contains a call to a virtual function,
    the virtual function call is resolved as if the function was called inside function <code>f</code>:</p>

<pre>
struct Window 
{
  Window() POST(isClosed());
  virtual bool isClosed() const;
  virtual void open() PRE(isClosed());
}; 

struct SpecialWindow : Window
{
  bool isClosed() const override;
  void open() override;
};

int main()
{
  SpecialWindow w {}; <em>// calls Window::isClosed(), because virtual function calls are not resolved in constructors </em>
  w.open();           <em>// calls SpecialWindow::isClosed(), because isClosed is virtual</em>
}
</pre>

<p> As a consequence of the above decsions, we do not allow the preconditions in the overriding function to be "wider"
    and the postconditions to be "narrower" than in the overridden function,
    even though this idea &mdash; one aspect of the Liskov Substitution Principle &mdash; is well explored and implemented in other languages.
		The reason for this is that we do not yet have a good understanding of what effect this principle should have on the feature design.
		Should it be just a "best practice" that the programmers are taught? Or should it be enforced by the language? But how?
		We could think of a number of ways. Given the declarations:</p>
		
<pre>
struct Base {
  virtual void f() PRE(p1());
};

struct Deriv : Base {
  void f() override PRE(p2());
};
</pre>

<ol>
<li> Should compiler be able to prove (even if it cannot see the definitions of <code>p1</code> and <code>p2</code>) 
    that the latter is no stricter than the former?</li>
<li> Shall the compiler report an error unless
    the precondition in the overriding function has the form <code>p1() || p2()</code>? </li>
<li> Or should the compiler accept this code and evaluate <code>p1() &amp;&amp; p2()</code> when <code>Deriv::f</code> is called through the <code>Base</code> interface,
     but evaluate predicate <code>p2()</code> when <code>Deriv::f</code> is called directly?     		
</ol>
		
<p>Option 1 is clearly impossible. The other options might be implementable, but it is more like a guess,
    as we know of no implementation experience with these.</p>

<p> However, the decision to add support for this feature can be deferred for later, because the way we specify the feature now
    (ill formed) remains open for future extensions in any of the three directions.
		</p> 		


<h4><a name="pro.vir.tmp">3.7.1 Class templates
        <span class="link">{pro.vir.tmp}</span></a></h4>
				
<p> The same restrictions for virtual functions apply for class templates, except that compilation errors might be deferred till 
    template instantiation time:</p>
	
<pre>
struct Base1 {
  virtual void f1(int i);
};

struct Base2 {
  virtual void f2(int i);
};

template &lt;typename Base&gt;
struct Deriv : Base {
  void f2(int i) PRE(i &gt; 0); <em>// ok, so far</em>
};

Deriv&lt;Base1&gt; d1 {}; <em>// ok</em>
Deriv&lt;Base2&gt; d2 {}; <em>// compiler error</em>
</pre>	

<h4><a name="pro.vir.two">3.7.2 Inheriting multiple contracts
        <span class="link">{pro.vir.two}</span></a></h4>

<p> In case a member function overrides two functions from two base classess
    with possibly two different set of pre- and postconditions,
    its precondition is the logical conjunction of the preconditions in the overridden functions,
    and it postcondition is the logical conjunction of the postconditions in the 
    overridden functions:
		</p>
		
<pre>
struct Base1 {
  virtual void f(int i) PRE(p1()) POST(r1());
};

struct Base2 {
  virtual void f(int i) PRE(p2()) POST(r2());
};

struct Deriv : Base1, Base2 {
  void 2(int i) override
    <em>// inherited:</em>
    <em>// PRE(p1()) PRE(p2()) POST(r1()) POST(r2())</em>
  ;
};
</pre>

	
<h3><a name="pro.imm">3.8. Contract annotations and the immediate context
    <span class="link">{pro.imm}</span></a></h3>


<p> In this proposal the predicates in contract annotations are <em>not</em> in the
    immediate context of the function. They behave similarly to exception specification:</p>

<pre>
template &lt;std::regular T&gt;
void f(T v, T u)
  PRE(v &lt; u); <em>// not part of std::regular</em>

template &lt;typename T&gt;
constexpr bool has_f =
  std::regular&lt;T&gt; &amp;&amp;
  requires(T v, T u) { f(v, u); };

static_assert( has_f&lt;std::string&gt;);         <em>// OK: has_f returns true</em>
static_assert(!has_f&lt;std::complex&lt;float&gt;&gt;); <em>// ill-formed: has_f causes hard instantiation error</em>
</pre>


<p> As a consequence, we may have a function template that works well for
    a given type, but stops working the moment we add a contract annotation.
    This also affects how concepts would be taught: a good concept should express
    not only the requirements that are necessary in the <em>implementation</em>
    of the generic algorithms, but also those that are necessary in the
    specification of contract annotations in these algorithms.
    </p>


<h3><a name="pro.end">3.9. <code>abort()</code> vs <code>terminate()</code> <span class="link">{pro.end}</span></a></h3>

<p> In this proposal, throwing from the predicate calls <code>std::terminate()</code> while a failed runtime check
    aborts the application even more abruptly: close to calling <code>std::abort()</code>, but we do not require 
		the actual call to <code>std::abort()</code>, as the function may not be present in freestanding. </p>

<p>	We do not require the implementations to allow the users to install custom contract violation handlers, nor do we
    specify any interface describing how this is done. However, we do not actively forbid the implementations form performing some logic,
		as long as it never throws or calls <code>longjmp()</code>. 
		This makes the MVP proposal smaller; but it remians open for the contract violation handler support in the future.
    </p>

<p> The above distinction reflects the fundamental difference between the two situations.
    Throwing from a predicate is analogous to throwing from a noexcept function &mdash; 
		an expected response to an unhandled exception thrown in procedural code &mdash; 
		but it does not signal that the program state itself is corrupt, or that the program has a logic error, which is what a contract violation detects.
		Maybe a comparison
    had to allocate memory, and this allocation failed, because today the server is exceptionally busy. We want to
    handle it the way we usually handle exceptions when there is no suitable handler: <code>std::terminate()</code>
    is an exception handler, with its unique control flow, however harsh.</p>

<p> In contrast, failing a runtime correctness test is an indication of a bug, and it is not clear if <code>std::terminate()</code>,
    which is the second level of exception handling mechanism, is a suitable tool. The call to <code>std::terminate()</code>
    either calls <code>std::abort()</code> or calls a terminate handler installed by the user. In case the contract is
    violated, and we can be sure the program contains a bug, calling a user-installed function may be unsafe,
    and can pose a security risk.</p>

<p> Moreover, <code>std::terminate()</code> is not available in freestanding implementations. </p>


<h3><a name="pro.log">3.10. No runtime error message<span class="link">{pro.log}</span></a></h3>

<p> This revision of the paper does not require or encourage
    any error message to be displayed to standard diagnostic stream, or anywhere
    in <em>Eval_and_abort</em> mode.
    There are two reasons. First, there is no standard diagnostic stream on
    freestanding implementations, and we want contract support to be available on
    those platforms. Second, for security reasons. When an application is in a confirmed
    incorrect state, performing IO operations may pose a security risk.
    As the primary focus of this proposal is safety, we choose a conservative
    approach.</p>
		
<p> Note that breaking into a debugger upon contract violation is a valid way to handle these situations,
    as it takes a single instruction and does not depend on program state.</p>
		

<h3><a name="pro.dec">3.11. Contract annotations upon the first and subsequent declarations<span class="link">{pro.dec}</span></a></h3>

<p> We require that if a given function <code>f</code> has declared preconditions and postconditions, they shall be visible in the first
    declaration of <code>f</code> in a translation unit (TU): otherwise the program is ill-formed. Subsequent declarations must omit 
    contract annotations. If <code>f</code> is declared in more than one TU,
    the corresponding first declarations of <code>f</code> shall be identical (modulo parameter names): otherwise the program is ill-formed with no
    diagnostic required. As a consequence, the following is illegal:</p>
		
<pre>
int select(int i, int j);  <em>// first declaration</em>
	
int select(int i, int j)   <em>// second declaration</em>
  PRE(i &gt;= 0)              <em>// error: initial decl has no contract annotations</em>
  PRE(j &gt;= 0)
  POST(r: r &gt;= 0); 
</pre>

<p>The following is also illegal</p>

<pre>
int select(int i, int j)  <em>// first declaration</em>
  PRE(i &gt;= 0)
  PRE(j &gt;= 0)
  POST(r: r &gt;= 0);
	
int select(int i, int j)   <em>// second declaration</em>
  PRE(i &gt;= 0)              <em>// error: contract annotations on redeclaration</em>
  PRE(j &gt;= 0)
  POST(r: r &gt;= 0); 
</pre>

<p> The reason for this restriction is implementability issues, similar to those for default function arguments.
    This decision departs from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">[P0542R5]</a>,
		which allowed putting odr-identical contract annotations on redeclarations. The reason we do not allow contract annotations on
		redeclarations is because this way we avoid the reason to define the notion of being "odr-identical".</p>



<h3><a id="pro.arg">3.12. Non-reference parameters mentioned in postconditions must be <code>const</code><span class="link">{pro.arg}</span></a></h3>


<p> If a non-reference function parameter is named in a postcondition, that parameter shall be declared <code>const</code> in every declaration of
    the function.</p> 
		
<pre>
int generate(int lo, int hi)              <em>// error: lo and hi should be declared const</em>
  PRE(lo &lt;= hi)
  POST(r: lo &lt;= r &amp;&amp; r &lt;= hi);
	
int generate(int&amp; lo, const int&amp; hi)      <em>// ok: lo and hi are references</em>
  PRE(lo &lt;= hi)
  POST(r: lo &lt;= r &amp;&amp; r &lt;= hi);
	
int generate(int lo, int hi)              <em>// ok: lo and hi not referenced in a postcondition</em>
  PRE(lo &lt;= hi)
  POST(r: r &gt;= 0);
	
int generate(const int lo, const int hi)  <em>// ok: lo and hi are declared const</em>
  PRE(lo &lt;= hi)
  POST(r: lo &lt;= r &amp;&amp; r &lt;= hi);
</pre>
 
<p> This is to prevent the situation where a contract check would return an answer
    incompatible with the programmer expectations: a false positive or a false negative.
		This problem has been explained in detail in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a>
    and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2466r0.html">[P2466R0]</a>.
		Here, we only show an example that demonstrates the issue:</p>
		
<pre><em>// declaration that the user sees:</em>
int generate(int lo, int hi)
  PRE(lo &lt;= hi)
  POST(r: lo &lt;= r &amp;&amp; r &lt;= hi);

<em>// definition that only the author sees:</em>
int generate(int lo, int hi)
{
  int result = lo;
  while (++lo &lt;= hi) <em>// note: lo modified</em>
  {
    if (further())
      ++result;      <em>// incremented slower than lo</em>
  }
  return result;     <em>// at this point result &lt; lo</em>
}

<em>// usage:</em>
int min = 1;
int max = 10;

int r = generate(min, max);   <em>// postcondition check fails</em>
assert(min &lt;= r &amp;&amp; r &lt;= max); <em>// even though this assertion is satisfied</em>
</pre>

<p> How is this problem addressed in other languages?
    In D, this problem has been ignored: postconditions like the one above give false positive or false negative results.
		In ADA this problem does not occur: this is due to the way the function arguments are designed. In ADA, for each 
		function argument, the programmer has to specify if it is IN or OUT or INOUT. The OUT and INOUT parameters correspond to reference
    parameters in C++, so there is no problem here. The IN parameters, on the other hand, are immutable, so there is no question of 
    changing them inside the function: IN parameters correspond to <code>const</code> by-value parameters in C++.
    SG21 decided to follow what ADA does, in the following poll on 2022-03-10.		
</p>	

<p> Poll: Adopt a change based on option #2 from the paper 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r1.html">[P2521R1]</a> section 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r1.html#con.arg">4.3</a>: 
    if the postcondtion uses a non-reference parameter: require it to be const objects.</p>

<table class="poll">
<tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
<tr><td>5</td><td>6</td><td>0</td><td>1</td><td>0</td></tr>
</table>
	
<p> This decision has the following consequences. First, in the MVP contracts, the programers have the 
    following options when they need their postconditions to refer to non-reference function parameters:</p>
	
<ol>
  <li>Do not reflect this postcondition in a contract annotation. (Do what you do in C++20, put it in a comment...)</li>
	<li>Add the otherwise redundant <code>const</code> qualifier.</li>
</ol>

<p> Second, this implies that once a postcondition starts reference a non-reference function parameter, 
    the language rules that govern this parameter change: now the additional <code>const</code> qualifier
		makes a difference: programmers can no longer choose to add it or omit it between declarations:
		</p>
		
<pre>
void f(int i) POST(i != 0);       <em>// error: i must be const </em>

void g(const int i) POST(i != 0);
void g(int i) {}                  <em>// error: missing const for i in definition</em>

void h(const int i) POST(i != 0);
void h(const int i) {} 
void h(int i);                    <em>// error: missing const for i in redeclaration</em>
</pre>

<p> This choice guarantees that compiler statically prevents any modifications to these functin parameters: both in the function body
    and in the contract predicates: </p>
	
<pre>
void f(const int i) 
  POST(++i != 0)                 <em>// error: cannot mutate a const object</em>
  POST(is_const_v&lt;decltype(i)&gt;); <em>// postcondition satisfied</em>

void f(const int i)
{
  ++i;                           <em>// error: cannot mutate a const object</em>
}	
</pre>

<p> One consequence of this is that you cannot use move-semantics for function parameters referenced in postconditions:</p>
	
<pre>
void f(unique_ptr&lt;int&gt; i) 
  PRE(i)                        <em>// ok (no restrictions for preconditions)</em>
{
  return i;                     <em>// ok: move</em>
}

void g(const unique_ptr&lt;int&gt; i) <em>// const is now required</em> 
  PRE(i)              
  POST(i)
{
  ++*i;
  return i;                     <em>// error: copy constructor inaccessible</em>
}
</pre>	
	
<p>The additional <code>const</code> qualifier still does not affect the type of the function:</p>

<pre>
int f(const int i) 
  POST(r: r != i);

int (*fp)(int) = &amp;f; <em>// ok</em>
</pre>



<h4><a id="pro.arg.out">3.12.1 Can the problem be avoided by inspecting function arguments instead?<span class="link">{pro.arg.out}</span></a></h4>


<p> It has been suggested that the problem with function parameters referenced in postconditions could be avoided if we checked the values of function 
    arguments used to initialize the function parameters, instead of checking the parameters themselves:</p>
		
<pre>
int f(int i) POST(r: r != i);

int a = 1;
int b = f(a); <em>// in postcondition read value of `a` rather than value of `i`</em>
</pre>

<p> This idea will not work for more complex cases, unless a copy of the argument is made on the side. 
    First, you cannot assume that the value of the argument remains unchanged as the function is executed, due to aliasing problem.
		</p>

<pre>
int f(int a, int&amp; ref)
  POST(r: r != a)
{
  --ref;
  return a - 1;
}

int i = 1;
f(i, i);   <em>// at the end of f(), `i` has different value than `a`</em>
</pre>
	
<p> Another problem with the proposed idea is that we may not have the function argument of the same type as the function parameter:</p>

<pre>
string f(string s)
  POST(r: s.empty() || r == s);

auto x = "text"; <em>// type of `x` is `const char*`</em>
f(x);            <em>// cannot call `x.empty()`</em>
</pre> 	
	



<h2><a id="con">4. Controversial aspects <span class="link">{con}</span></a></h2>	


<p>This section lists points of controversy inside SG21 for the recent contract design. For each of these points, we
   require a poll to be taken, to determine the group direction.</p>



<h3><a id="con.syn">4.1. The choice of syntax<span class="link">{con.syn}</span></a></h3>


<p> There are two visions for the syntax to describe contract annotations with significant support in SG21.</p>

<p>One is to use notation similar to attributes (but not 100% compatible with attributes):</p>

<pre>int select(int i, int j)
  [[pre: i &gt;= 0]]
  [[pre: j &gt;= 0]]
  [[post r: r &gt;= 0]]      <em>// r names the return value</em>
{
  [[assert: _state &gt;= 0]];

  if (_state == 0) return i;
  else             return j;
}
</pre>

<p>The other is to use notation similar to lambdas (but not 100% compatible with lambdas):</p>

<pre>int select(int i, int j)
  pre{ i &gt;= 0 }
  pre{ j &gt;= 0 }
  post(r){ r &gt;= 0 }      <em>// r names the return value</em>
{
  assert{ _state &gt;= 0 };

  if (_state == 0) return i;
  else             return j;
}
</pre>

<p> The rationale for using the later syntax has been provided in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">[P2461R1]</a>.
    The analysis of pros and cons of using the former syntax has been provided in
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2487r0.html">[P2487R0]</a>.
		</p>

<p> The primary argument in favor of quasi-attribute notation is to stress semantic characteristics similar to attributes. 
    The common understanding of attributes is that they are hints for generating warnings or performing optimizations. Their removal
		should not affect the correctness of the program (even though it is easy to construct an example using <code>no_unique_address</code>
		that contradicts this claim).</p>
		
<p> Contract annotations &mdash; at least one model thereof &mdash; shares similar features: they are hints for tools for generating warnings
    or emitting an instrumentation code. If these annotations are removed <em>from a correct program</em> (one that does not violate the declared
		contract annotations), this does not affect the correctness of the program.
    </p> 
		
<p> The primary arguments in favor of quasi-lambda syntax is to avoid the problems reported for quasi-attribute syntax 
    (e.g., that they look like attributes but do not follow other characteristics of attributes) and to offer an intuitive
		syntax for one of the future extensions: making copies of function arguments for use in postconditions.



<h4><a id="con.syn.arg">4.1.1 The capacity to copy function arguments (post MVP)<span class="link">{con.syn.arg}</span></a></h4>

<p> This section describes a future extension, not proposed for the MVP: the ability to make copies of function arguments (or parts thereof) 
    upon user request, to be later referenced in postconditions. However, the capability to handle this extension is related to the choice of syntax.</p>

<p> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">[P2461R1]</a> proposes the following syntax:
		</p>

<pre>
int generate(int lo, int hi)
  pre{ lo &lt;= hi }
  post[lo, hi](r){ lo &lt;= r &amp;&amp; r &lt;= hi }; <em>// `hi` and `lo` refer to internal copies of function parameters.</em>
</pre>

<p> The lambda-introducer syntax should make it immediately clear, even for the uninitiated programmers, that a copy of function parameters is being made.</p>

<p> The quasi-attribute notation also allows this as a future extension, however this would require a new notation, which comes with a complexity and an aesthetical cost:</p>

<pre>
int generate(int lo, int hi)
  [[pre: lo &lt;= hi ]]
  [[post r, old_lo = lo, old_hi = hi: old_lo &lt;= r &amp;&amp; r &lt;= old_hi ]];
	
// or some alternate notation

int generate(int lo, int hi)
  [[pre: lo &lt;= hi ]]
  [[post r, =lo, =hi: lo &lt;= r &amp;&amp; r &lt;= hi ]];
	
// or a notation using lambda-capture:

int generate(int lo, int hi)
  [[pre: lo &lt;= hi ]]
  [[post [lo, hi] r: lo &lt;= r &amp;&amp; r &lt;= hi ]];
</pre>  

<p> Thus, the decision how to address the issue of by-value arguments in postconditions is somewhat tied to the choice of syntax.
    But perhaps not as much as one might think at first.</p>

<p> It should be noted <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">[P2461R1]</a> offers more motivation than
    the quasi-lambda syntax than solving the problem of function arguments in postconditions. The notable exmple is the support for "oldof" values:</p>

<pre>
void vector::push_back(T const&amp; val)
  POST(r: size() == OLDOF(size()) + 1);
	
// in P2461R1, post-MVP:

void vector::push_back(T const&amp; val)
  post [old_size = size()]{ size() == oldof_size + 1 };

// in P2388R4, post-MVP:

void vector::push_back(T const&amp; val)
  [[post old_size = size(): size() == old_size + 1]];
	
// or:

void vector::push_back(T const&amp; val)
  [[post [old_size = size()]: size() == old_size + 1]];
</pre>	




<h3><a id="con.eff">4.2. Removal and duplication of side effects in predicates<span class="link">{con.eff}</span></a></h3>


<p> Some implementation strategies may need to evaluate the same predicate in a precondition twice.
    For direct function calls, an implementation can easily insert the instrumentation code in the caller.
		This is desired as it gives better diagnostics. However, this is impossible when a function is called indirectly,
    either through a pointer or <code>std::function</code>: from the pointer signature we do not know if a function called
		has a precondition or not. To address that case, one thing an implementation could do is to compile the pre- and 
		post-condition checks into the function body. This would give the result that the pre-/post-conditions are checked normally
    when the function is called through an indirection, but are checked twice when the function is called directly: 
		once in the caller, and once inside the function body. We may want to enable such implementation strategies.		
		The consequence for the programmer is that when the predicate has side effects, these effects occur twice.</p>

<p> Putting side effects in contract annotaitons and later relying on them is a practice that we would like actively discourage.
    As of today, we do not know how to do it statically (so that each such side effect would be reported as a compiler error).
		For the purpose of discouraging programmers from putting observable side effects in their contract annotations,
		an implementation might want not to evaluate the predicate, if it already knows what its result would be.
    This can happen when a function that produces a value has sufficiently similar postcondition <code>p</code> to the precondition of another function
    that subsequently consume the same value, and we do not see the body of <code>p</code>:</p>
		
<pre>
bool p(int); <em>// defined in a different TU</em>

int produce() POST(r: p(r));
void consume(int i) PRE(p(i));

int main() {
  consume(produce()); <em>// can p() be called once</em>
}
</pre>

<p> This seems redundant to call the same predicate twice. Of course, this seems so only if <code>p()</code> doesn't have side effects.
    If it does, and the program (or the programmer) relies on them, this elision can make the comprehension of the program harder,
		and the effects surprising.</p>

<p> Both	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a> and
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">[P2461R1]</a> propose this capability to remove and duplicate the
		evaluation of the predicates. However, concerns have been expressed about it.</p>


<p> Note that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">[P2388R4]</a> additionally proposes the 
    "partial elision" of side effects in a predicate. We received a feedback that the group is against it, so this "partial elision" is 
		not considered in this paper.</p>		


	
	<!--
<h2><a name="ope">5. Open issues
    <span class="link">{ope}</span></a></h2>

<h3><a name="ope.two">5.1. Open issues
    <span class="link">{ope.two}</span></a></h3>
		
<p> There is a situation where a class has two bases and each of thee bases has
    a virtual funciton with the same name and signature, but with different contract 
		annotations:</p>
-->

<h2><a name="ack">5. Acknowledgements
    <span class="link">{ack}</span></a></h2>
		
<p> This paper is a summary of SG21 discussions; all SG21 members contributed to this paper. 
    John McFarlane suggeted the idea to make implicit copies of trivilly-copyable types. 
		Walter E. Brown pointed out that putting pre-/post-condition checks inside function bodies is not a necessity, 
    and that alternate implementations &mdash; such as a thunk &mdash; exist.</p>


<h2><a name="ref">6. References
    <span class="link">{ref}</span></a></h2>

<ul>

  <li>[P0542R5] — G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup,
      "Support for contract based programming in C++" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html</a>).
      </li>
			
	<li>[P1289R1] — J. Daniel Garcia, Ville Voutilainen, "Access control in contract conditions" <br>
		(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1289r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1289r1.pdf</a>).
		</li>
			
  <li>[P1323R2] — Hubert S.K. Tong, "Contract postconditions and return type deduction" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1323r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1323r2.html</a>).
      </li>
	
  <li>[P2388R4] — Andrzej Krzemieński, Gašper Ažman, "Minimum Contract Support: either No_eval or Eval_and_abort" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2388r4.html</a>).
      </li>
	
  <li>[P2461R1] — Gašper Ažman, Caleb Sunstrum, Bronek Kozicki, "Closure-Based Syntax for Contracts" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2461r1.pdf</a>).
      </li>	
			
  <li>[P2466R0] — Andrzej Krzemieński, "The notes on contract annotations" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2466r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2466r0.html</a>).
      </li>	

  <li>[P2487R0] — Andrzej Krzemieński, "Attribute-like syntax for contract annotations" <br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2487r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2487r0.html</a>).
      </li>		
	
  <li>[P2521R1] — Gašper Ažman, Joshua Berne, Bronek Kozicki, Andrzej Krzemieński, Ryan McDougall, Caleb Sunstrum, "Contract support — Working Paper" (the previous revision of this paper)<br>
      (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2521r1.html</a>).
      </li>	
	
			
</ul>


</body></html>
